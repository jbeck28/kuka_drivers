#ifndef EGM_BASE_INTERFACE_H
#define EGM_BASE_INTERFACE_H

#include <boost/thread.hpp>

// #include "abb_libegm_export.h"
// // 
// #include "egm.pb.h"         // Generated by Google Protocol Buffer compiler protoc
// #include "egm_wrapper.pb.h" // Generated by Google Protocol Buffer compiler protoc

// #include "egm_common.h"
// #include "egm_logger.h"
// #include "egm_udp_server.h"
#include "generic_udp_server.h"

namespace kuka
{
namespace rsi
{

/**
 * \brief Class for processing asynchronous callbacks.
 *
 * The class provides behavior for:
 * - Processing asynchronous callbacks from a UDP server. The interface receives the robot controller's
 *   outbound messages and construct inbound messages to the robot controller.
 * - This class can for example be used as a foundation for custom made user interfaces.
 */
class EGMBaseInterface
{
public:
  /**
   * \brief A constructor.
   *
   * \param io_service for operating boost asio's asynchronous functions.
   * \param port_number for the server's UDP socket.
   * \param configuration for the interface's configuration.
   */
  EGMBaseInterface(boost::asio::io_service& io_service,
                   const unsigned short port_number
                   );

  /**
   * \brief Checks if the underlying server was successfully initialized or not.
   *
   * \return bool indicating if the underlying server was successfully initialized or not.
   */
  bool isInitialized();

  /**
   * \brief Checks if an EGM communication session is connected or not.
   *
   * \return bool indicating if a connection exists between the interface, and the robot controller's EGM client.
   */
  bool isConnected();

  /**
   * \brief Retrieve the most recently received EGM status message.
   *
   * The returned status depends on the EGM communication session(s):
   * - If no session has been active, then an empty status message is returned.
   * - If a session is active, then the most recently received status message is returned.
   * - If any session has been active, then the last status message from the latest session is returned.
   *
   * Note: EGMAct RAPID instructions specifies the frequency of EGM messages, and this affects how often
   *       the status is updated when a communication session is active.
   *
   * \return wrapper::Status containing the most recently received EGM status message.
   */
//   wrapper::Status getStatus();

  /**
   * \brief Retrieve the interface's current configuration.
   *
   * \return BaseConfiguration containing the current configurations for the interface.
   */
//   BaseConfiguration getConfiguration();

  /**
   * \brief Update the interface's configuration (update is only applied for new EGM communication sessions).
   *
   * \param configuration containing the new configurations for the interface.
   */
//   void setConfiguration(const BaseConfiguration& configuration);

protected:


  /**
   * \brief Struct for containing data regarding an active EGM communication session.
   */
  struct SessionData
  {
    /**
     * \brief Container for the most recently received EGM header message.
     */
    // wrapper::Header header;

    // /**
    //  * \brief Container for the most recently received EGM status message.
    //  */
    // wrapper::Status status;

    /**
     * \brief Mutex for protecting the session data.
     */
    boost::mutex mutex;
  };

//   /**
//    * \brief Log input, from robot controller, and output, to robot controller, into a CSV file.
//    *
//    * \param inputs containing the inputs from the robot controller.
//    * \param outputs containing the outputs to the robot controller.
//    * \param max_time specifying the max amount of time to log.
//    */
//   void logData(const InputContainer& inputs, const OutputContainer& outputs, const double max_time);

//   /**
//    * \brief Initialize the callback.
//    *
//    * \param server_data containing the UDP server's callback data.
//    *
//    * \return bool indicating if the initialization succeeded or not.
//    */
  bool initializeCallback(const UDPServerData& server_data);

  /**
   * \brief Static constant wait time [ms] used when determining if a connection has been established or not.
   *
   * I.e. a connection between the interface's UDP server, and a robot controller's EGM client.
   */
  static const unsigned int WAIT_TIME_MS = 100;

//   /**
//    * \brief Container for the inputs, to the interface, from the UDP server.
//    */
//   InputContainer inputs_;

//   /**
//    * \brief Container for the outputs, from the interface, to the UDP server.
//    */
//   OutputContainer outputs_;

//   /**
//    * \brief Container for session data (most recently received header and status messages).
//    */
  SessionData session_data_;

  /**
   * \brief Logger, for logging EGM messages to a CSV file.
   */
//   boost::shared_ptr<EGMLogger> p_logger_;

//   /**
//    * \brief The interface's configuration.
//    */
//   BaseConfigurationContainer configuration_;

//   /**
//    * \brief Server for managing the communication with the robot controller.
//    */
  UDPServer udp_server_;

private:
  /**
   * \brief Handle callback requests from an UDP server.
   *
   * \param server_data containing the UDP server's callback data.
   *
   * \return string& containing the reply.
   */
  const std::string& callback(const UDPServerData& server_data);
};

} // end namespace kuka
} // end namespace rsi

#endif // RSI_UDP_SERVER.H